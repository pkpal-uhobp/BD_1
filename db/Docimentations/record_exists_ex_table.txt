Метод record_exists_ex_table() класса DB

Назначение:
Вспомогательный приватный метод для проверки существования таблицы в базе данных на уровне самой БД (а не в метаданных приложения). Использует SQLAlchemy inspector для получения списка таблиц непосредственно из системы БД.

Параметры:
- table_name (str): название таблицы для проверки существования
  Примеры: "Books", "Readers", "Issued_Books", "NonExistentTable"

Возвращаемое значение:
- bool: True - если таблица существует в базе данных
- bool: False - если таблица не существует, нет подключения или произошла ошибка

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки наличия активного соединения
   - Если нет подключения, возвращает False

2. Инспекция БД:
   - Создает SQLAlchemy inspector объект через inspect(self.engine)
   - Вызывает inspector.get_table_names() для получения списка всех таблиц в БД

3. Проверка существования:
   - Проверяет наличие table_name в списке полученных таблиц
   - Возвращает True если таблица найдена, False если нет

4. Обработка исключений:
   - При любых ошибках возвращает False (без выбрасывания исключений)

Примеры вызова:

1. Проверка существования стандартных таблиц:
   db = DB()
   if db.connect():
       # Проверяем существование таблиц
       print(f"Books существует: {db.record_exists_ex_table('Books')}")
       print(f"Readers существует: {db.record_exists_ex_table('Readers')}")
       print(f"Issued_Books существует: {db.record_exists_ex_table('Issued_Books')}")

2. Проверка несуществующих таблиц:
   db = DB()
   db.connect()
   exists = db.record_exists_ex_table('NonExistentTable')
   print(f"Несуществующая таблица: {exists}")  # Вывод: False

3. Использование перед операциями:
   def safe_table_operation(db, table_name):
       if not db.record_exists_ex_table(table_name):
           print(f"Таблица {table_name} не существует в БД")
           return False

       # Можно безопасно работать с таблицей
       data = db.get_table_data(table_name)
       print(f"Получено {len(data)} записей из {table_name}")
       return True

4. С обработкой ошибок:
   db = DB()
   try:
       if db.connect():
           exists = db.record_exists_ex_table('SomeTable')
           if exists:
               print("Таблица существует")
           else:
               print("Таблица не существует или ошибка подключения")
   except Exception as e:
       print(f"Неожиданная ошибка: {e}")

5. Для диагностики состояния БД:
   def diagnose_database_tables(db):
       if not db.is_connected():
           print("Нет подключения к БД")
           return

       expected_tables = ['Books', 'Readers', 'Issued_Books']
       print("Диагностика таблиц БД:")

       for table in expected_tables:
           exists = db.record_exists_ex_table(table)
           status = "✓" if exists else "✗"
           print(f"  {status} {table}")

       # Проверяем все таблицы в БД
       all_tables = db.get_table_names()  # Другой метод получения таблиц
       unexpected_tables = set(all_tables) - set(expected_tables)
       if unexpected_tables:
           print(f"  ⚠ Непредвиденные таблицы: {unexpected_tables}")

Использование в других методах:
Метод вызывается автоматически из:
- get_joined_summary() - для проверки существования таблиц перед JOIN операциями
- Может использоваться в других методах для дополнительной проверки

Пример интеграции:
   def get_joined_summary(self, left_table: str, right_table: str, ...):
       # Проверка существования таблиц
       if not self.record_exists_ex_table(left_table):
           msg = f"Левая таблица '{left_table}' не существует в БД"
           self.logger.error(msg)
           return []

       if not self.record_exists_ex_table(right_table):
           msg = f"Правая таблица '{right_table}' не существует в БД"
           self.logger.error(msg)
           return []

Особенности:
- Приватный метод (вспомогательный, используется внутри класса)
- Проверяет реальное существование таблиц в БД (не в метаданных)
- Не выбрасывает исключений при ошибках (возвращает False)
- Быстрая операция - только чтение системных метаданных
- Потокобезопасный метод

Логирование:
- Метод не производит прямого логирования
- Ошибки подавляются и возвращается False

Производительность:
- Использует системные представления БД для получения списка таблиц
- Минимальная нагрузка на БД
- Быстрое выполнение для любых размеров БД

Ограничения:
- Требует прав на чтение системных метаданных
- Проверяет только пользовательские таблицы (не системные)
- Может не учитывать временные таблицы или представления
- Зависит от прав пользователя в БД

Рекомендации по использованию:
- Используется внутренне другими методами класса
- Полезен для предварительной проверки перед операциями с таблицами
- Может применяться для диагностики состояния БД
- Не вызывайте напрямую в обычных сценариях использования

Различия от других методов проверки:
- record_exists_ex_table(): проверяет существование в БД
- проверка в self.tables: проверяет существование в метаданных приложения
- get_table_names(): возвращает все таблицы БД (более подробная информация)

Примеры возвращаемых значений:
- db.record_exists_ex_table("Books") → True (если таблица существует)
- db.record_exists_ex_table("NonExistent") → False (если таблица не существует)
- db.record_exists_ex_table("Books") → False (если нет подключения)
- db.record_exists_ex_table("") → False (пустое имя таблицы)

Пример комплексного использования:
   def validate_database_schema(db):
       """Проверяет соответствие схемы БД ожиданиям"""
       required_tables = ['Books', 'Readers', 'Issued_Books']
       missing_tables = []

       for table in required_tables:
           if not db.record_exists_ex_table(table):
               missing_tables.append(table)

       if missing_tables:
           print(f"Отсутствующие таблицы: {missing_tables}")
           return False
       else:
           print("Все необходимые таблицы присутствуют")
           return True