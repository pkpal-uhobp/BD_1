Метод get_joined_summary() класса DB

Назначение:
Возвращает сводные данные из двух таблиц через JOIN операцию. Универсальный метод для выполнения соединений таблиц с возможностью фильтрации, сортировки и выбора конкретных колонок.

Параметры:
- left_table (str): название левой таблицы для JOIN
  Примеры: "Books", "Readers", "Issued_Books"

- right_table (str): название правой таблицы для JOIN
  Примеры: "Readers", "Books", "Issued_Books"

- join_on (tuple): кортеж с именами колонок для соединения в формате (левая_колонка, правая_колонка)
  Примеры:
    ("id_book", "book_id") - соединение Books.id_book = Issued_Books.book_id
    ("reader_id", "reader_id") - соединение Readers.reader_id = Issued_Books.reader_id

- columns (List[str], опционально): список колонок для выборки (по умолчанию None - все колонки)
  Примеры:
    ["b.title", "r.last_name", "i.issue_date"]
    ["Books.title", "Readers.last_name"]
    None (выбрать все колонки)

- condition (Dict[str, Any], опционально): словарь с условиями фильтрации (по умолчанию None)
  Формат: {колонка: значение} или {полный_путь_колонки: значение}
  Примеры:
    {"genre": "Роман"}
    {"b.actual_return_date": None}
    {"Readers.discount_category": "Студент"}

- sort_columns (List[tuple], опционально): список кортежей для сортировки (по умолчанию None)
  Формат: [(колонка, направление), ...] где направление: True=ASC, False=DESC
  Примеры:
    [("b.issue_date", False)] - сортировка по дате по убыванию
    [("Readers.last_name", True), ("Books.title", True)] - составная сортировка

Возвращаемое значение:
- List[Dict[str, Any]]: список словарей с результатами JOIN (пустой список если ошибка или нет данных)
- Каждый словарь представляет одну строку результата соединения
- Пример:
  [
    {'title': 'Война и мир', 'last_name': 'Иванов', 'issue_date': '2023-12-01'},
    {'title': 'Анна Каренина', 'last_name': 'Петров', 'issue_date': '2023-12-05'}
  ]

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки наличия активного соединения
   - Если нет подключения, возвращает пустой список

2. Проверка существования таблиц:
   - Вызывает record_exists_ex_table() для проверки существования обеих таблиц в БД
   - Если одна из таблиц не существует, возвращает пустой список

3. Получение колонок таблиц:
   - Вызывает get_column_names() для получения структуры обеих таблиц
   - Используется для автоматического построения SELECT и разрешения колонок

4. Построение SELECT части запроса:
   - Если columns не указан, формирует список всех колонок обеих таблиц с префиксами
   - Если columns указан, использует указанный список
   - Добавляет префиксы таблиц (t1. и t2.) для избежания конфликтов имен

5. Построение JOIN части запроса:
   - Формирует JOIN условие на основе join_on параметра
   - Использует INNER JOIN для соединения таблиц

6. Построение WHERE условий (если condition задан):
   - Проверяет существование колонок в таблицах
   - Разрешает колонки с префиксами таблиц
   - Формирует WHERE условия с параметрами

7. Построение ORDER BY условий (если sort_columns задан):
   - Проверяет существование колонок для сортировки
   - Разрешает колонки с префиксами таблиц
   - Формирует ORDER BY условия с направлениями

8. Выполнение запроса:
   - Вызывает execute_query() с построенным SQL-запросом
   - Получает результаты в формате словарей

9. Логирование:
   - ERROR: "Нет подключения к БД"
   - ERROR: "Левая таблица '{left_table}' не существует в БД"
   - ERROR: "Правая таблица '{right_table}' не существует в БД"
   - ERROR: "Не удалось получить список колонок для JOIN {left_table} и {right_table}"
   - INFO: "Выполнение JOIN-запроса: {query_for_log}"
   - DEBUG: "Параметры JOIN-запроса: {params}"
   - INFO: "Получено {count} записей из JOIN таблиц '{left_table}' и '{right_table}'"
   - ERROR: "Не удалось выполнить JOIN между '{left_table}' и '{right_table}'"
   - ERROR: "Ошибка выполнения JOIN-запроса для '{left_table}' и '{right_table}': {сообщение ошибки}"

Примеры вызова:

1. Простой JOIN между Books и Issued_Books:
   db = DB()
   if db.connect():
       results = db.get_joined_summary(
           left_table="Books",
           right_table="Issued_Books",
           join_on=("id_book", "book_id"),
           columns=["title", "authors", "issue_date", "actual_return_date"],
           condition={"actual_return_date": None}  # Активные выдачи
       )
       for row in results:
           print(f"Книга '{row['title']}' выдана")

2. JOIN с сортировкой и фильтрацией:
   db = DB()
   db.connect()
   results = db.get_joined_summary(
           left_table="Readers",
           right_table="Issued_Books",
           join_on=("reader_id", "reader_id"),
           columns=["last_name", "first_name", "issue_date", "expected_return_date"],
           condition={"actual_return_date": None},  # Активные выдачи
           sort_columns=[("issue_date", False)]  # По убыванию даты выдачи
       )
       for row in results:
           print(f"{row['last_name']} {row['first_name']} - выдано {row['issue_date']}")

3. JOIN трех таблиц через последовательные вызовы:
   db = DB()
   db.connect()
   # Сначала Books + Issued_Books
   books_issues = db.get_joined_summary(
           left_table="Books",
           right_table="Issued_Books",
           join_on=("id_book", "book_id"),
           columns=["id_book", "title", "issue_id", "reader_id", "issue_date"]
       )

   # Затем результат + Readers (это пример - для трех таблиц лучше использовать execute_query)
   # В реальности для трех таблиц используйте execute_query с двойным JOIN

4. С обработкой ошибок:
   db = DB()
   try:
       if db.connect():
           results = db.get_joined_summary(
               left_table="Books",
               right_table="NonExistentTable",
               join_on=("id_book", "book_id")
           )
           if not results:
               print("Ошибка или нет данных")
   except Exception as e:
       print(f"Ошибка: {e}")

5. Для отчетов по активным выдачам:
   def get_active_issues_report(db):
       return db.get_joined_summary(
           left_table="Books",
           right_table="Issued_Books",
           join_on=("id_book", "book_id"),
           columns=["title", "authors", "issue_date", "expected_return_date"],
           condition={"actual_return_date": None},
           sort_columns=[("expected_return_date", True)]  # По возрастанию срока возврата
       )

6. Для анализа популярности книг:
   def get_book_popularity(db):
       return db.get_joined_summary(
           left_table="Books",
           right_table="Issued_Books",
           join_on=("id_book", "book_id"),
           columns=["title", "authors", "COUNT(*) as issue_count"],
           sort_columns=[("issue_count", False)]
       )

Побочные эффекты:
- Выполняет SELECT-запрос с JOIN к БД (операция чтения)
- Запись JOIN-операций в лог-файл
- Использование памяти пропорционально объему возвращаемых данных
- Не модифицирует данные в БД

Особенности:
- Только чтение - безопасная операция
- Поддерживает INNER JOIN между двумя таблицами
- Автоматическое разрешение колонок с префиксами
- Поддерживает фильтрацию и сортировку результатов
- Преобразует данные в удобный формат словарей
- Проверяет существование таблиц перед выполнением
- Потокобезопасный метод

Логирование операций:
- ERROR: "Нет подключения к БД"
- ERROR: "Левая таблица '{left_table}' не существует в БД"
- ERROR: "Правая таблица '{right_table}' не существует в БД"
- ERROR: "Не удалось получить список колонок для JOIN {left_table} и {right_table}"
- INFO: "Выполнение JOIN-запроса: {query_for_log}"
- DEBUG: "Параметры JOIN-запроса: {params}"
- INFO: "Получено {count} записей из JOIN таблиц '{left_table}' и '{right_table}'"
- ERROR: "Не удалось выполнить JOIN между '{left_table}' и '{right_table}'"
- ERROR: "Ошибка выполнения JOIN-запроса для '{left_table}' и '{right_table}': {сообщение ошибки}"

Ограничения:
- Поддерживает только INNER JOIN между двумя таблицами
- Требует прав на чтение из обеих таблиц
- Не поддерживает сложные условия фильтрации (>, <, LIKE и т.д.)
- Может быть ресурсоемким для больших таблиц
- Не поддерживает агрегатные функции без дополнительной обработки

Рекомендации по использованию:
- Используйте индексы на колонках JOIN для лучшей производительности
- Ограничивайте объем возвращаемых данных для больших таблиц
- Используйте condition для фильтрации перед JOIN
- Для сложных JOIN с тремя и более таблицами используйте execute_query()
- Указывайте columns явно для лучшей производительности

Примеры параметров:
- join_on=("id_book", "book_id") - Books.id_book = Issued_Books.book_id
- columns=["title", "last_name", "issue_date"]
- condition={"actual_return_date": None}
- sort_columns=[("issue_date", False), ("title", True)]

Пример комплексного использования:
   def get_library_overview_report(db):
       # Получаем список активных выдач с информацией о книгах и читателях
       active_issues = db.get_joined_summary(
           left_table="Books",
           right_table="Issued_Books",
           join_on=("id_book", "book_id"),
           columns=["title", "authors", "issue_date", "expected_return_date"],
           condition={"actual_return_date": None},
           sort_columns=[("expected_return_date", True)]
       )

       # Получаем список читателей с количеством активных выдач
       reader_stats = db.execute_query("""
           SELECT r.last_name, r.first_name, COUNT(i.issue_id) as active_issues
           FROM "Readers" r
           LEFT JOIN "Issued_Books" i ON r.reader_id = i.reader_id
           AND i.actual_return_date IS NULL
           GROUP BY r.reader_id, r.last_name, r.first_name
           HAVING COUNT(i.issue_id) > 0
           ORDER BY active_issues DESC
       """, fetch="dict")

       return {
           "active_issues": active_issues,
           "busy_readers": reader_stats
       }

   # Использование:
   db = DB()
   db.connect()
   report = get_library_overview_report(db)
   print("Активные выдачи:")
   for issue in report['active_issues']:
       print(f"  {issue['title']} - до {issue['expected_return_date']}")

   print("\nАктивные читатели:")
   for reader in report['busy_readers']:
       print(f"  {reader['last_name']} {reader['first_name']} - {reader['active_issues']} книг")