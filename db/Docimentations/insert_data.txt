Метод insert_data() класса DB

Назначение:
Вставляет одну запись в указанную таблицу с предварительной валидацией данных и проверкой внешних ключей. Выполняет DML-операцию INSERT с использованием транзакций для обеспечения целостности данных.

Параметры:
- table_name (str): название таблицы, в которую вставляется запись
  Примеры: "Books", "Readers", "Issued_Books"

- data (Dict[str, Any]): словарь с данными для вставки
  Пример: {"title": "Война и мир", "authors": ["Л.Н. Толстой"], "genre": "Роман", ...}

Возвращаемое значение:
- bool: True - если запись успешно вставлена
- bool: False - если произошла ошибка валидации, подключения или выполнения

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки наличия активного соединения
   - Если нет подключения, возвращает False

2. Валидация данных:
   - Вызывает _validate_data() для проверки соответствия структуре таблицы
   - Проверяет типы данных, обязательные поля, ограничения
   - Логирует ошибки валидации

3. Проверка внешних ключей (для Issued_Books):
   - Проверяет существование book_id в таблице Books
   - Проверяет существование reader_id в таблице Readers
   - Логирует ошибки при отсутствии связанных записей

4. Выполнение INSERT операции:
   - Создает INSERT запрос с использованием SQLAlchemy
   - Выполняет запрос в транзакции (engine.begin())
   - Получает ID вставленной записи (если есть автоинкремент)

5. Логирование:
   - INFO: "Выполнение DML: INSERT INTO \"{table_name}\" ({list(data.keys())})" (перед выполнением)
   - INFO: "Успешно вставлена 1 запись в таблицу '{table_name}' (ID: {inserted_id})" (при успехе)
   - WARNING: "Ошибки валидации данных для таблицы '{table_name}':" (при ошибках валидации)
   - ERROR: "Книга с id_book = {book_id} не существует..." (при ошибках внешних ключей)
   - ERROR: "Ошибка при вставке в '{table_name}': {сообщение ошибки}" (при исключениях)

Примеры вызова:

1. Вставка книги:
   db = DB()
   if db.connect() and db.create_schema():
       success = db.insert_data("Books", {
           "title": "Война и мир",
           "authors": ["Л.Н. Толстой"],
           "genre": "Роман",
           "deposit_amount": 500.00,
           "daily_rental_rate": 10.00
       })
       if success:
           print("Книга успешно добавлена")
       else:
           print("Ошибка добавления книги")

2. Вставка читателя:
   db = DB()
   db.connect()
   success = db.insert_data("Readers", {
       "last_name": "Иванов",
       "first_name": "Иван",
       "middle_name": "Иванович",
       "phone": "+7(999)123-45-67",
       "discount_category": "Студент",
       "discount_percent": 10
   })
   if success:
       print("Читатель успешно зарегистрирован")

3. Вставка выдачи книги (с проверкой внешних ключей):
   db = DB()
   db.connect()
   # Сначала добавляем книгу и читателя
   db.insert_data("Books", {
       "title": "Преступление и наказание",
       "authors": ["Ф.М. Достоевский"],
       "genre": "Роман",
       "deposit_amount": 400.00,
       "daily_rental_rate": 8.00
   })
   db.insert_data("Readers", {
       "last_name": "Петров",
       "first_name": "Петр",
       "phone": "+7(999)987-65-43"
   })

   # Теперь можно добавить выдачу (предполагая что ID книги=1, читателя=1)
   success = db.insert_data("Issued_Books", {
       "book_id": 1,
       "reader_id": 1,
       "issue_date": "2023-12-01",
       "expected_return_date": "2023-12-15"
   })
   if success:
       print("Книга выдана читателю")

4. С обработкой ошибок валидации:
   db = DB()
   db.connect()
   # Попытка вставить некорректные данные
   success = db.insert_data("Books", {
       "title": None,  # Обязательное поле
       "authors": [],  # Должен быть не пустой массив
       "genre": "Несуществующий жанр",  # Недопустимое значение
       "deposit_amount": -100.00  # Отрицательное значение
   })
   if not success:
       print("Данные не прошли валидацию")

5. Для массовой вставки (в цикле):
   def bulk_insert_books(db, books_list):
       successful_inserts = 0
       for book_data in books_list:
           if db.insert_data("Books", book_data):
               successful_inserts += 1
           else:
               print(f"Не удалось вставить книгу: {book_data.get('title', 'Без названия')}")
       return successful_inserts

Побочные эффекты:
- Выполняет INSERT-запрос к БД (модификация данных)
- Запись DML-операций в лог-файл
- Использование транзакций для обеспечения целостности
- Увеличение количества записей в таблице
- Генерация автоинкрементных значений (если применимо)

Особенности:
- Использует транзакции для атомарности операций
- Выполняет комплексную валидацию перед вставкой
- Автоматически проверяет внешние ключи для Issued_Books
- Поддерживает все типы данных SQLAlchemy (ARRAY, ENUM, Numeric, Date)
- Потокобезопасный метод

Логирование операций:
- INFO: "Выполнение DML: INSERT INTO \"{table_name}\" ({list(data.keys())})"
- INFO: "Успешно вставлена 1 запись в таблицу '{table_name}' (ID: {inserted_id})"
- WARNING: "Ошибки валидации данных для таблицы '{table_name}':" с перечислением ошибок
- ERROR: "Книга с id_book = {book_id} не существует. Сначала добавьте книгу."
- ERROR: "Ошибка при вставке в '{table_name}': {сообщение ошибки}"

Ограничения:
- Вставляет только одну запись за вызов
- Требует прав на INSERT в указанную таблицу
- Зависит от существования таблицы и правильной структуры данных
- Может быть медленным при частых вызовах (лучше использовать bulk операции для множества записей)

Рекомендации по использованию:
- Используйте для вставки отдельных записей
- Выполняйте предварительную валидацию данных
- Проверяйте подключение перед вызовом
- Используйте в комбинации с get_table_data() для проверки результатов
- Для массовой вставки рассмотрите использование транзакций с множественными INSERT

Примеры структур данных для вставки:

Для Books:
{
    "title": "Название книги",
    "authors": ["Автор 1", "Автор 2"],
    "genre": "Роман",
    "deposit_amount": 500.00,
    "daily_rental_rate": 10.00
}

Для Readers:
{
    "last_name": "Фамилия",
    "first_name": "Имя",
    "middle_name": "Отчество",
    "phone": "+7(999)123-45-67",
    "discount_category": "Студент",
    "discount_percent": 10
}

Для Issued_Books:
{
    "book_id": 1,
    "reader_id": 1,
    "issue_date": "2023-12-01",
    "expected_return_date": "2023-12-15"
}

Пример комплексного использования:
   def register_new_reader_with_books(db, reader_data, books_to_issue):
       # Добавляем читателя
       if not db.insert_data("Readers", reader_data):
           return False

       # Получаем ID нового читателя (предполагаем что он последний)
       readers = db.get_table_data("Readers")
       reader_id = readers[-1]['reader_id'] if readers else None

       if not reader_id:
           return False

       # Выдаем книги
       for book_id in books_to_issue:
           db.insert_data("Issued_Books", {
               "book_id": book_id,
               "reader_id": reader_id,
               "issue_date": date.today().isoformat(),
               "expected_return_date": (date.today() + timedelta(days=14)).isoformat()
           })

       return True