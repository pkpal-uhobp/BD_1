Метод count_records_filtered() класса DB

Назначение:
Возвращает количество записей в указанной таблице, удовлетворяющих заданному условию (если оно есть). Выполняет SELECT-запрос с агрегатной функцией COUNT(*). Не изменяет данные — только читает.

Параметры:
- table_name (str): название таблицы, в которой подсчитывается количество записей
  Примеры: "Books", "Readers", "Issued_Books"

- condition (Dict[str, Any], опционально): словарь с условиями фильтрации в формате {колонка: значение}. Условия объединяются через AND. Если None — подсчитываются все записи таблицы.
  Примеры:
    {"genre": "Роман"}
    {"reader_id": 5, "actual_return_date": None}
    {"paid": False}

Возвращаемое значение:
- int: количество записей, удовлетворяющих условию (включая 0, если записей нет)
- В случае ошибки (нет подключения, неверное имя таблицы и т.д.) — возвращает 0

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки активного соединения
   - Если соединение отсутствует — возвращает 0

2. Построение SQL-запроса:
   - Формирует базовый запрос: SELECT COUNT(*) FROM "{table_name}"
   - Если передан condition, добавляет WHERE с условиями вида col = :param_X
   - Параметры привязываются безопасно через словарь params (защита от SQL-инъекций)

3. Выполнение запроса:
   - Использует внутренний метод execute_query() с параметром fetch="one"
   - Ожидает возврат одного кортежа с одним значением — результат COUNT(*)

4. Обработка результата:
   - Если результат получен — возвращает result[0]
   - Если результат пуст (что маловероятно для COUNT(*)) — возвращает 0

5. Обработка ошибок:
   - При любой ошибке выполнения (например, несуществующая таблица, неверная колонка) — логирует ошибку и возвращает 0

Логирование:
- ERROR: "Ошибка подсчёта с условием в '{table_name}': {сообщение ошибки}" — при возникновении исключения

Примеры вызова:

1. Подсчёт всех книг:
   db = DB()
   if db.connect():
       total_books = db.count_records_filtered("Books")
       print(f"Всего книг в библиотеке: {total_books}")

2. Подсчёт непрочитанных выдач (не возвращённых):
   db = DB()
   db.connect()
   active_issues = db.count_records_filtered("Issued_Books", {"actual_return_date": None})
   print(f"Активных выдач: {active_issues}")

3. Подсчёт читателей с определённой скидкой:
   veterans_count = db.count_records_filtered("Readers", {"discount_category": "Ветеран"})
   print(f"Читателей-ветеранов: {veterans_count}")

4. Использование в условии перед обновлением (проверка, есть ли что обновлять):
   def safe_update_genre_deposit(db, genre: str, new_deposit: float):
       count = db.count_records_filtered("Books", {"genre": genre})
       if count == 0:
           print(f"Книг жанра '{genre}' не найдено")
           return False
       print(f"Найдено {count} книг для обновления залога")
       success = db.update_data("Books", {"genre": genre}, {"deposit_amount": new_deposit})
       return success

5. С обработкой ошибок (хотя метод сам возвращает 0 при ошибке):
   try:
       count = db.count_records_filtered("NonExistentTable", {"id": 1})
       if count == 0:
           print("Либо таблица не существует, либо условию не соответствует ни одна запись")
   except Exception as e:
       print(f"Неожиданная ошибка: {e}")

Побочные эффекты:
- Выполняет SELECT-запрос к БД (без модификации данных)
- Записывает ошибки в лог-файл при возникновении исключений
- Не использует транзакции (не требуется для SELECT)
- Не изменяет состояние БД

Особенности:
- Безопасность: использует параметризованные запросы — защищено от SQL-инъекций
- Производительность: COUNT(*) может быть медленным на больших таблицах без индексов по условиям
- Ограничения условий: поддерживает только точное совпадение (=) и объединение через AND
- Не проверяет существование колонок — если указана несуществующая колонка, вызовет ошибку SQL, которая будет залогирована и вернёт 0
- Не требует прав на запись — достаточно прав на чтение (SELECT)
- Потокобезопасный — если execute_query() и соединение потокобезопасны

Логирование операций:
- ERROR: "Ошибка подсчёта с условием в '{table_name}': {сообщение ошибки}"

Ограничения:
- Не поддерживает условия с операторами >, <, LIKE, IN, IS NULL и т.д.
- Не валидирует существование таблицы и колонок заранее — полагается на СУБД
- Не возвращает информацию об ошибке вызывающему коду — только логирует и возвращает 0
- Не поддерживает OR-условия
- Не поддерживает группировку или подсчёт по категориям

Рекомендации по использованию:
- Используйте для получения количества перед массовыми операциями (например, обновлением или удалением)
- Не используйте для сложных условий — вместо этого вызывайте execute_query() с кастомным SQL
- Помните, что COUNT(*) может быть медленным — для частых вызовов рассмотрите кэширование или материализованные представления
- Всегда проверяйте возвращаемое значение — 0 может означать как отсутствие записей, так и ошибку

Примеры условий:
- condition=None → подсчёт всех записей
- {"status": "active"} → подсчёт записей со статусом "active"
- {"category": "Fiction", "language": "RU"} → подсчёт записей, где категория = "Fiction" И язык = "RU"

Пример комплексного использования:
   def generate_statistics(db: DB):
       """Генерирует простую статистику по библиотеке."""
       stats = {
           "total_books": db.count_records_filtered("Books"),
           "available_books": db.count_records_filtered("Books", {"is_available": True}),
           "total_readers": db.count_records_filtered("Readers"),
           "active_issues": db.count_records_filtered("Issued_Books", {"actual_return_date": None}),
           "overdue_issues": db.count_records_filtered("Issued_Books", {"is_overdue": True}),
           "veteran_readers": db.count_records_filtered("Readers", {"discount_category": "Ветеран"})
       }
       print("=== Статистика библиотеки ===")
       for key, value in stats.items():
           print(f"{key.replace('_', ' ').title()}: {value}")
       return stats

Возможные улучшения (в будущем):
- Добавить поддержку операторов: {"price__gt": 100}, {"title__like": "%Python%"}
- Добавить логирование успешных операций (INFO)
- Добавить валидацию существования таблицы и колонок перед запросом
- Вернуть кортеж (count, success) или выбрасывать исключение при ошибке — для лучшей отладки

Этот метод является безопасным и удобным инструментом для получения количественных метрик из БД, особенно в связке с другими методами класса DB, такими как update_data() или record_exists().