Метод delete_data() класса DB

Назначение:
Удаляет записи из указанной таблицы, удовлетворяющие заданному условию. Выполняет DML-операцию DELETE с использованием транзакций для обеспечения целостности данных.

Параметры:
- table_name (str): название таблицы, из которой удаляются записи
  Примеры: "Books", "Readers", "Issued_Books"

- condition (Dict[str, Any]): словарь с условиями удаления в формате {колонка: значение}
  Примеры:
    {"id_book": 1}
    {"genre": "Роман"}
    {"reader_id": 5, "actual_return_date": None}

Возвращаемое значение:
- bool: True - если операция выполнена (даже если не удалено ни одной записи)
- bool: False - если произошла ошибка подключения, таблица не существует или другая ошибка

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки наличия активного соединения
   - Если нет подключения, возвращает False

2. Проверка существования таблицы:
   - Проверяет наличие table_name в self.tables
   - Если таблица не определена в метаданных, возвращает False

3. Построение WHERE условий:
   - Проверяет существование указанных колонок в таблице
   - Формирует список WHERE условий с параметрами
   - Логирует предупреждения для несуществующих колонок

4. Выполнение DELETE операции:
   - Создает DELETE запрос с WHERE условиями
   - Выполняет запрос в транзакции (engine.begin())
   - Получает количество удаленных записей через rowcount

5. Логирование:
   - INFO: "Выполнение DML: DELETE FROM \"{table_name}\" WHERE {condition}" (перед выполнением)
   - INFO: "Удалено {deleted_count} записей из таблицы '{table_name}'" (если удалены записи)
   - INFO: "Условию {condition} не соответствует ни одна запись в таблице '{table_name}'" (если ничего не удалено)
   - ERROR: "Таблица '{table_name}' не определена в метаданных приложения" (если таблица не найдена)
   - WARNING: "Предупреждение: колонки не существуют в таблице '{table_name}': {invalid_columns}" (для невалидных колонок)
   - ERROR: "Не указаны корректные условия для удаления" (если все колонки невалидны)
   - ERROR: "Ошибка при удалении из '{table_name}': {сообщение ошибки}" (при исключениях)

Примеры вызова:

1. Удаление книги по ID:
   db = DB()
   if db.connect():
       success = db.delete_data("Books", {"id_book": 1})
       if success:
           print("Книга удалена")
       else:
           print("Ошибка удаления книги")

2. Удаление всех книг определенного жанра:
   db = DB()
   db.connect()
   success = db.delete_data("Books", {"genre": "Ужасы"})
   if success:
           print("Все книги жанра 'Ужасы' удалены")

3. Удаление читателя (с каскадным удалением выдач):
   db = DB()
   db.connect()
   success = db.delete_data("Readers", {"reader_id": 5})
   if success:
           print("Читатель и все его выдачи удалены")

4. Удаление активных выдач:
   db = DB()
   db.connect()
   success = db.delete_data("Issued_Books", {
       "reader_id": 1,
       "actual_return_date": None  # Активные выдачи
   })
   if success:
           print("Активные выдачи удалены")

5. С обработкой ошибок:
   db = DB()
   try:
       if db.connect():
           # Попытка удаления с несуществующей колонкой
           success = db.delete_data("Books", {"nonexistent_column": "value"})
           # Будет выведено предупреждение в лог

           # Корректное удаление
           success = db.delete_data("Books", {"id_book": 1})
           if success:
               print("Удаление выполнено")
   except Exception as e:
       print(f"Ошибка: {e}")

6. Удаление с проверкой результата:
   def delete_book_safely(db, book_id):
       # Проверяем существование книги перед удалением
       if not db.record_exists("Books", {"id_book": book_id}):
           print("Книга не найдена")
           return False

       # Выполняем удаление
       if db.delete_data("Books", {"id_book": book_id}):
           print("Книга успешно удалена")
           return True
       else:
           print("Ошибка при удалении книги")
           return False

Побочные эффекты:
- Выполняет DELETE-запрос к БД (модификация данных)
- Запись DML-операций в лог-файл
- Использование транзакций для обеспечения целостности
- Удаление записей из таблицы (возможно каскадное удаление)
- Изменение количества записей в таблице

Особенности:
- Использует транзакции для атомарности операций
- Поддерживает составные условия удаления (AND)
- Проверяет существование колонок перед выполнением
- Учитывает каскадные ограничения внешних ключей
- Потокобезопасный метод

Логирование операций:
- INFO: "Выполнение DML: DELETE FROM \"{table_name}\" WHERE {condition}"
- INFO: "Удалено {deleted_count} записей из таблицы '{table_name}'"
- INFO: "Условию {condition} не соответствует ни одна запись в таблице '{table_name}'"
- ERROR: "Таблица '{table_name}' не определена в метаданных приложения"
- WARNING: "Предупреждение: колонки не существуют в таблице '{table_name}': {invalid_columns}"
- ERROR: "Не указаны корректные условия для удаления"
- ERROR: "Ошибка при удалении из '{table_name}': {сообщение ошибки}"

Ограничения:
- Требует прав на DELETE в указанной таблице
- Условия объединяются логическим AND
- Не поддерживает сложные условия (>, <, LIKE и т.д.)
- Может быть ограничено каскадными ограничениями БД
- Не возвращает список удаленных записей (только количество)

Рекомендации по использованию:
- Используйте осторожно - операция необратима
- Выполняйте резервное копирование перед массовыми удалениями
- Проверяйте условия удаления перед выполнением
- Используйте в комбинации с record_exists() для проверки существования
- Для сложных удалений используйте execute_query() с произвольным SQL

Примеры условий удаления:
- {"id_book": 1} - удаление по первичному ключу
- {"genre": "Ужасы"} - удаление по жанру
- {"reader_id": 5, "actual_return_date": None} - составное условие
- {"deposit_amount": 0} - удаление по значению поля

Пример комплексного использования:
   def cleanup_old_issues(db, days_old=365):
       from datetime import date, timedelta

       # Вычисляем дату для удаления старых выдач
       cutoff_date = date.today() - timedelta(days=days_old)

       # Удаляем возвращенные книги, выданные более года назад
       success = db.delete_data("Issued_Books", {
           "actual_return_date": None,  # Не возвращенные
           "issue_date": {"<": cutoff_date.isoformat()}  # Но это пример - сложные условия не поддерживаются
       })

       # Для сложных условий используем execute_query:
       query = """
       DELETE FROM "Issued_Books"
       WHERE actual_return_date IS NOT NULL
       AND issue_date < :cutoff_date
       """
       result = db.execute_query(query, {"cutoff_date": cutoff_date.isoformat()})

       return result if result is not None else 0

Предупреждения безопасности:
  ОПЕРАЦИЯ УДАЛЕНИЯ НЕОБРАТИМА
  ПЕРЕД УДАЛЕНИЕМ СДЕЛАЙТЕ РЕЗЕРВНУЮ КОПИЮ
  ПРОВЕРЯЙТЕ УСЛОВИЯ УДАЛЕНИЯ ДВАЖДЫ
  УЧИТЫВАЙТЕ КАСКАДНЫЕ УДАЛЕНИЯ