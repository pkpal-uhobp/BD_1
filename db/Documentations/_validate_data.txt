Метод _validate_data() класса DB

Назначение:
Приватный метод валидации данных перед вставкой или обновлением записей в таблицу. Проверяет соответствие данных структуре таблицы, включая типы, обязательные поля, ограничения и допустимые значения.

Параметры:
- table_name (str): название таблицы, для которой проводится валидация
  Примеры: "Books", "Readers", "Issued_Books"

- data (Dict[str, Any]): словарь с данными для валидации
  Пример: {"title": "Война и мир", "authors": ["Л.Н. Толстой"], "genre": "Роман", ...}

Возвращаемое значение:
- List[str]: список строк с описаниями ошибок валидации
- Пустой список если данные прошли валидацию успешно
- Пример: ["Поле 'title' обязательно (NOT NULL), но получено NULL", "Поле 'genre' имеет недопустимое значение 'Неизвестный жанр'"]

Выполняемые действия:

1. Проверка существования таблицы:
   - Проверяет наличие table_name в self.tables
   - Если таблица не существует, возвращает ошибку

2. Валидация каждой колонки:
   - Проверяет NOT NULL ограничения (кроме автоинкрементных PK)
   - Проверяет типы данных
   - Проверяет специфичные ограничения (даты, числа, ENUM)
   - Проверяет значения ENUM полей

3. Специфичные проверки:
   - Для Date: формат 'YYYY-MM-DD'
   - Для Numeric: неотрицательность для определенных полей
   - Для ARRAY: тип списка
   - Для ENUM: допустимые значения

Примеры вызова:

1. Валидация данных для Books:
   db = DB()
   db.connect()
   db._build_metadata()  # Убедиться что метаданные загружены

   # Корректные данные
   valid_data = {
       "title": "Война и мир",
       "authors": ["Л.Н. Толстой"],
       "genre": "Роман",
       "deposit_amount": 500.00,
       "daily_rental_rate": 10.00
   }
   errors = db._validate_data("Books", valid_data)
   print(f"Ошибки: {errors}")  # Вывод: []

   # Некорректные данные
   invalid_data = {
       "title": None,  # Обязательное поле
       "authors": [],  # Должен быть не пустой массив
       "genre": "Неизвестный жанр",  # Недопустимое значение ENUM
       "deposit_amount": -100.00,  # Отрицательное значение
       "daily_rental_rate": 0  # Должно быть > 0
   }
   errors = db._validate_data("Books", invalid_data)
   for error in errors:
       print(f"Ошибка: {error}")

2. Валидация данных для Readers:
   db = DB()
   valid_reader = {
       "last_name": "Иванов",
       "first_name": "Иван",
       "middle_name": "Иванович",
       "phone": "+7(999)123-45-67",
       "discount_category": "Студент",
       "discount_percent": 10
   }
   errors = db._validate_data("Readers", valid_reader)
   print(f"Ошибки валидации читателя: {len(errors)}")

3. Валидация с автоинкрементным полем:
   # PK с autoincrement не проверяется если None
   book_data = {
       "id_book": None,  # Будет проигнорировано для autoincrement
       "title": "Новая книга",
       "authors": ["Автор"],
       "genre": "Роман",
       "deposit_amount": 300.00,
       "daily_rental_rate": 15.00
   }
   errors = db._validate_data("Books", book_data)
   # id_book не вызовет ошибку, так как это autoincrement PK

Правила валидации:

1. NOT NULL поля:
   - Проверяются все поля с nullable=False
   - Исключение: автоинкрементные первичные ключи со значением None

2. Типы данных:
   - String, Enum → str
   - Integer → int
   - Numeric → int, float
   - Date → str (формат 'YYYY-MM-DD'), date
   - Boolean → bool
   - ARRAY → list

3. Специфичные проверки:
   - Date строки должны быть в формате 'YYYY-MM-DD'
   - Numeric поля deposit_amount, daily_rental_rate, damage_fine не могут быть отрицательными
   - ENUM поля должны содержать допустимые значения
   - ARRAY полей должен быть непустым (для authors)

Примеры ошибок валидации:
- "Поле 'title' обязательно (NOT NULL), но получено NULL"
- "Поле 'authors' обязательно (NOT NULL), но получено NULL"
- "Поле 'genre' имеет недопустимое значение 'Неизвестный жанр'. Допустимые: ['Роман', 'Повесть', ...]"
- "Поле 'issue_date' должно быть в формате 'YYYY-MM-DD', получено: '2023/12/01'"
- "Поле 'deposit_amount' не может быть отрицательным"
- "Поле 'id_book' имеет неверный тип. Ожидался <class 'int'>, получен <class 'str'>"

Использование в других методах:
Метод вызывается автоматически из:
- insert_data() - перед вставкой новых записей
- update_data() - перед обновлением записей

Пример интеграции:
   def insert_data(self, table_name: str, data: Dict[str, Any]) -> bool:
       # Сначала валидация
       validation_errors = self._validate_data(table_name, data)
       if validation_errors:
           for error in validation_errors:
               self.logger.warning(f"  - {error}")
           return False
       # Затем вставка
       # ... остальной код вставки

Особенности:
- Приватный метод (начинается с _)
- Не выполняет запросов к БД
- Только локальная проверка структуры данных
- Не проверяет внешние ключи (это делает _check_foreign_key_exists)
- Не модифицирует входные данные

Логирование:
- Метод не производит прямого логирования
- Ошибки возвращаются вызывающему методу для логирования

Рекомендации по использованию:
- Не вызывайте напрямую (используется внутренне)
- Полезен для понимания правил валидации данных
- Может использоваться для предварительной проверки перед bulk операциями