Метод get_sorted_data() класса DB

Назначение:
Возвращает записи из указанной таблицы, отсортированные по заданным колонкам, с возможностью фильтрации по условиям. Выполняет SELECT-запрос с ORDER BY и WHERE условиями.

Параметры:
- table_name (str): название таблицы, из которой извлекаются данные
  Примеры: "Books", "Readers", "Issued_Books"

- sort_columns (List[tuple]): список кортежей в формате (колонка, направление_сортировки)
  Формат: [(колонка1, True/False), (колонка2, True/False), ...]
  Где: True = ASC (по возрастанию), False = DESC (по убыванию)
  Примеры:
    [("title", True)] - сортировка по названию по возрастанию
    [("issue_date", False), ("reader_id", True)] - сортировка по дате по убыванию, затем по ID читателя по возрастанию

- condition (Dict[str, Any], опционально): словарь с условиями фильтрации (по умолчанию None)
  Формат: {колонка: значение}
  Примеры:
    {"genre": "Роман"}
    {"actual_return_date": None}
    {"reader_id": 5, "paid": False}

Возвращаемое значение:
- List[Dict[str, Any]]: список словарей с отсортированными данными (пустой список если ошибка или нет данных)
- Каждый словарь представляет одну строку таблицы
- Пример:
  [
    {'id_book': 1, 'title': 'Анна Каренина', 'authors': ['Л.Н. Толстой'], ...},
    {'id_book': 2, 'title': 'Война и мир', 'authors': ['Л.Н. Толстой'], ...}
  ]

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки наличия активного соединения
   - Если нет подключения, возвращает пустой список

2. Проверка существования таблицы:
   - Проверяет наличие table_name в self.tables
   - Если таблица не определена в метаданных, возвращает пустой список

3. Построение WHERE условий (если condition задан):
   - Проверяет существование указанных колонок в таблице
   - Формирует список WHERE условий с параметрами
   - Логирует предупреждения для несуществующих колонок

4. Построение ORDER BY условий:
   - Проверяет существование колонок для сортировки
   - Формирует список ORDER BY условий с направлениями
   - Логирует предупреждения для несуществующих колонок сортировки

5. Выполнение SELECT-запроса:
   - Создает SELECT * запрос с WHERE и ORDER BY условиями
   - Выполняет запрос через engine.connect()
   - Преобразует результаты в список словарей

6. Логирование:
   - INFO: "Выполнение DML: SELECT * FROM \"{table_name}\" WHERE {where_info} ORDER BY {sort_info}" (перед выполнением)
   - INFO: "Получено {count} отсортированных строк из таблицы '{table_name}'" (при успехе)
   - ERROR: "Таблица '{table_name}' не определена в метаданных приложения"
   - WARNING: "Предупреждение: колонки в условии WHERE не существуют: {invalid_where_columns}"
   - WARNING: "Предупреждение: колонки для сортировки не существуют: {invalid_sort_columns}"
   - ERROR: "Ошибка получения отсортированных данных из '{table_name}': {сообщение ошибки}"

Примеры вызова:

1. Сортировка книг по названию:
   db = DB()
   if db.connect():
       sorted_books = db.get_sorted_data("Books", [("title", True)])
       for book in sorted_books:
           print(f"{book['title']} - {book['authors']}")

2. Сортировка читателей по фамилии и имени:
   db = DB()
   db.connect()
   sorted_readers = db.get_sorted_data("Readers",
                                      [("last_name", True), ("first_name", True)])
   for reader in sorted_readers:
       print(f"{reader['last_name']} {reader['first_name']}")

3. Сортировка выдач с фильтрацией по не возвращенным книгам:
   db = DB()
   db.connect()
   active_issues = db.get_sorted_data("Issued_Books",
                                     [("issue_date", False)],  # По убыванию даты
                                     {"actual_return_date": None})  # Только активные
   for issue in active_issues:
       print(f"Книга {issue['book_id']} выдана {issue['issue_date']}")

4. Сортировка с несколькими условиями:
   db = DB()
   db.connect()
   expensive_books = db.get_sorted_data("Books",
                                       [("deposit_amount", False)],  # По убыванию залога
                                       {"genre": "Роман"})  # Только романы
   for book in expensive_books:
       print(f"{book['title']} - залог: {book['deposit_amount']}")

5. С обработкой ошибок:
   db = DB()
   try:
       if db.connect():
           # С несуществующими колонками (будет предупреждение)
           data = db.get_sorted_data("Books",
                                   [("nonexistent_column", True)],
                                   {"another_nonexistent": "value"})
           if data:
               print(f"Получено {len(data)} записей")
           else:
               print("Нет данных или ошибки")
   except Exception as e:
       print(f"Ошибка: {e}")

6. Для отчетов и аналитики:
   def get_overdue_books_report(db):
       from datetime import date
       today = date.today().isoformat()

       overdue_issues = db.get_sorted_data("Issued_Books",
                                          [("expected_return_date", True)],  # По возрастанию срока
                                          {"actual_return_date": None,  # Не возвращены
                                           "expected_return_date": {"<": today}})  # Просрочены

       return overdue_issues

Побочные эффекты:
- Выполняет SELECT-запрос к БД (операция чтения)
- Запись DML-операций в лог-файл
- Использование памяти пропорционально объему возвращаемых данных
- Не модифицирует данные в БД

Особенности:
- Только чтение - безопасная операция
- Поддерживает составную сортировку по нескольким колонкам
- Поддерживает фильтрацию по условиям
- Преобразует данные в удобный формат словарей
- Проверяет существование колонок перед выполнением
- Потокобезопасный метод

Логирование операций:
- INFO: "Выполнение DML: SELECT * FROM \"{table_name}\" WHERE {where_info} ORDER BY {sort_info}"
- INFO: "Получено {count} отсортированных строк из таблицы '{table_name}'"
- ERROR: "Таблица '{table_name}' не определена в метаданных приложения"
- WARNING: "Предупреждение: колонки в условии WHERE не существуют: {invalid_where_columns}"
- WARNING: "Предупреждение: колонки для сортировки не существуют: {invalid_sort_columns}"
- ERROR: "Ошибка получения отсортированных данных из '{table_name}': {сообщение ошибки}"

Ограничения:
- Требует прав на чтение из таблицы
- Не поддерживает сложные условия фильтрации (>, <, LIKE и т.д.)
- Может быть ресурсоемким для больших таблиц без индексов
- Не поддерживает LIMIT/OFFSET для пагинации

Рекомендации по использованию:
- Используйте индексы на колонках сортировки для лучшей производительности
- Ограничивайте объем возвращаемых данных для больших таблиц
- Комбинируйте с condition для фильтрации перед сортировкой
- Используйте для генерации отчетов и списков
- Для сложных запросов используйте execute_query() с произвольным SQL

Примеры параметров сортировки:
- [("title", True)] - по названию по возрастанию
- [("deposit_amount", False)] - по залогу по убыванию
- [("last_name", True), ("first_name", True)] - составная сортировка
- [("issue_date", False), ("book_id", True)] - по дате по убыванию, ID по возрастанию

Примеры условий фильтрации:
- {"genre": "Роман"} - только романы
- {"actual_return_date": None} - только активные выдачи
- {"reader_id": 5, "paid": False} - составное условие

Пример комплексного использования:
   def get_reader_activity_report(db, reader_id):
       # Получаем информацию о читателе
       reader_info = db.execute_query(
           "SELECT * FROM \"Readers\" WHERE reader_id = :reader_id",
           {"reader_id": reader_id},
           fetch="one"
       )

       if not reader_info:
           return None

       # Получаем историю выдач читателя, отсортированную по дате
       issue_history = db.get_sorted_data("Issued_Books",
                                         [("issue_date", False)],  # По убыванию даты
                                         {"reader_id": reader_id})  # Только этого читателя

       # Разделяем активные и завершенные выдачи
       active_issues = [issue for issue in issue_history if issue['actual_return_date'] is None]
       completed_issues = [issue for issue in issue_history if issue['actual_return_date'] is not None]

       return {
           "reader": reader_info,
           "active_issues": active_issues,
           "completed_issues": completed_issues,
           "total_issues": len(issue_history)
       }

   # Использование:
   db = DB()
   db.connect()
   report = get_reader_activity_report(db, 1)
   if report:
       print(f"Читатель: {report['reader']['last_name']} {report['reader']['first_name']}")
       print(f"Активных выдач: {len(report['active_issues'])}")
       print(f"Всего выдач: {report['total_issues']}")