Метод execute_query() класса DB

Назначение:
Выполняет произвольный SQL-запрос к базе данных. Универсальный метод для выполнения SELECT, INSERT, UPDATE, DELETE и других SQL-операций с возможностью получения результатов в различных форматах.

Параметры:
- query (str): SQL-запрос для выполнения
  Примеры:
    "SELECT * FROM \"Books\" WHERE genre = 'Роман'"
    "INSERT INTO \"Readers\" (last_name, first_name) VALUES (:last_name, :first_name)"
    "UPDATE \"Books\" SET daily_rental_rate = :rate WHERE id_book = :book_id"
    "DELETE FROM \"Issued_Books\" WHERE actual_return_date IS NULL"

- params (Dict[str, Any], опционально): словарь параметров для SQL-запроса (по умолчанию None)
  Формат: {параметр: значение}
  Примеры:
    {"genre": "Роман", "rate": 15.00}
    {"last_name": "Иванов", "first_name": "Иван"}
    {"book_id": 1, "rate": 20.00}

- fetch (str, опционально): режим получения результатов (по умолчанию None)
  Возможные значения:
    "one" - получить одну строку результата
    "all" - получить все строки результата как кортежи
    "dict" - получить все строки результата как словари
    None - не возвращать результаты (для DML операций)
    Другие значения - возвращаются как есть через fetchall()

Возвращаемое значение:
- При fetch="one": Dict[str, Any] или Tuple[Any, ...] или None (если нет результатов)
- При fetch="all": List[Tuple[Any, ...]] или пустой список
- При fetch="dict": List[Dict[str, Any]] или пустой список
- При fetch=None: int (количество затронутых строк для DML операций)
- При других fetch: результат fetchall() как есть
- None - если ошибка или нет подключения

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки наличия активного соединения
   - Если нет подключения, возвращает None

2. Подготовка логирования:
   - Обрезает длинные запросы для лога (до 100 символов)
   - Добавляет "..." для обрезанных запросов

3. Выполнение запроса:
   - Использует engine.connect() для получения соединения
   - Выполняет запрос через conn.execute(text(query), params)
   - Обрабатывает параметры через named placeholders

4. Обработка результатов:
   - В зависимости от значения fetch возвращает соответствующий формат
   - Для fetch="dict" преобразует результаты в список словарей
   - Для fetch="one" возвращает одну запись или None
   - Для fetch=None возвращает количество затронутых строк

5. Логирование:
   - INFO: "Выполнение SQL-запроса: {query_for_log}" (перед выполнением)
   - DEBUG: "Параметры: {params}" (если есть параметры)
   - INFO: "Запрос вернул {count} строк (fetch='{fetch}')" (результаты)
   - INFO: "Запрос затронул {rowcount} строк (DML операция)" (для DML)
   - ERROR: "Ошибка выполнения SQL-запроса: {сообщение ошибки}" (при исключениях)

Примеры вызова:

1. SELECT запрос с получением всех результатов как словари:
   db = DB()
   if db.connect():
       books = db.execute_query(
           "SELECT * FROM \"Books\" WHERE genre = :genre",
           {"genre": "Роман"},
           fetch="dict"
       )
       if books:
           for book in books:
               print(f"{book['title']} - {book['authors']}")

2. SELECT запрос с получением одной записи:
   db = DB()
   db.connect()
   book = db.execute_query(
       "SELECT * FROM \"Books\" WHERE id_book = :book_id",
       {"book_id": 1},
       fetch="one"
   )
   if book:
       print(f"Найдена книга: {book['title']}")

3. INSERT запрос:
   db = DB()
   db.connect()
   affected_rows = db.execute_query(
       "INSERT INTO \"Readers\" (last_name, first_name, phone) VALUES (:last_name, :first_name, :phone)",
       {"last_name": "Петров", "first_name": "Петр", "phone": "+7(999)123-45-67"}
   )
   print(f"Добавлено записей: {affected_rows}")

4. UPDATE запрос:
   db = DB()
   db.connect()
   updated_rows = db.execute_query(
       "UPDATE \"Books\" SET daily_rental_rate = :rate WHERE id_book = :book_id",
       {"rate": 15.00, "book_id": 1}
   )
   print(f"Обновлено записей: {updated_rows}")

5. DELETE запрос:
   db = DB()
   db.connect()
   deleted_rows = db.execute_query(
       "DELETE FROM \"Issued_Books\" WHERE actual_return_date IS NOT NULL"
   )
   print(f"Удалено записей: {deleted_rows}")

6. Сложный запрос с JOIN:
   db = DB()
   db.connect()
   results = db.execute_query("""
       SELECT b.title, r.last_name, r.first_name, i.issue_date
       FROM "Issued_Books" i
       JOIN "Books" b ON i.book_id = b.id_book
       JOIN "Readers" r ON i.reader_id = r.reader_id
       WHERE i.actual_return_date IS NULL
       ORDER BY i.issue_date DESC
   """, fetch="dict")

   for row in results:
       print(f"{row['title']} выдана {row['last_name']} {row['first_name']} {row['issue_date']}")

7. С обработкой ошибок:
   db = DB()
   try:
       if db.connect():
           result = db.execute_query(
               "SELECT * FROM \"NonExistentTable\"",
               fetch="dict"
           )
           if result is None:
               print("Ошибка выполнения запроса")
           elif not result:
               print("Нет данных")
           else:
               print(f"Получено {len(result)} записей")
   except Exception as e:
       print(f"Ошибка: {e}")

8. Для агрегатных функций:
   db = DB()
   db.connect()
   stats = db.execute_query(
       "SELECT COUNT(*) as total_books, AVG(deposit_amount) as avg_deposit FROM \"Books\"",
       fetch="one"
   )
   if stats:
       print(f"Всего книг: {stats['total_books']}")
       print(f"Средний залог: {stats['avg_deposit']}")

Побочные эффекты:
- Выполняет произвольные SQL-запросы к БД
- Может модифицировать данные (для DML операций)
- Запись SQL-операций в лог-файл
- Использование памяти для хранения результатов
- Возможная нагрузка на БД в зависимости от сложности запроса

Особенности:
- Поддерживает все типы SQL-запросов
- Использует параметризованные запросы для безопасности
- Поддерживает различные форматы возврата результатов
- Обрезает длинные запросы в логах для читаемости
- Потокобезопасный метод

Логирование операций:
- INFO: "Выполнение SQL-запроса: {query_for_log}"
- DEBUG: "Параметры: {params}"
- INFO: "Запрос вернул {count} строк (fetch='{fetch}')"
- INFO: "Запрос затронул {rowcount} строк (DML операция)"
- INFO: "Запрос выполнен с нестандартным fetch='{fetch}'"
- INFO: "Запрос вернул 0 строк (fetch='one')"
- INFO: "Запрос вернул 1 строку (fetch='one')"
- ERROR: "Ошибка выполнения SQL-запроса: {сообщение ошибки}"

Ограничения:
- Требует прав на выполнение указанных операций в БД
- Зависит от корректности SQL-синтаксиса
- Может быть ресурсоемким для больших результатов
- Не выполняет автоматическую валидацию запросов

Рекомендации по использованию:
- Используйте параметризованные запросы для безопасности
- Будьте осторожны с запросами, возвращающими большие объемы данных
- Используйте fetch="dict" для удобства работы с результатами
- Применяйте fetch="one" для запросов, возвращающих одну запись
- Для DML операций используйте без fetch параметра
- Проверяйте подключение перед выполнением запросов

Примеры различных fetch режимов:
- fetch="dict": [{"id": 1, "name": "Иван"}, {"id": 2, "name": "Петр"}]
- fetch="all": [(1, "Иван"), (2, "Петр")]
- fetch="one": {"id": 1, "name": "Иван"} или (1, "Иван")
- fetch=None: 5 (количество затронутых строк)

Пример комплексного использования:
   def get_library_statistics(db):
       queries = {
           "total_books": "SELECT COUNT(*) FROM \"Books\"",
           "total_readers": "SELECT COUNT(*) FROM \"Readers\"",
           "active_issues": "SELECT COUNT(*) FROM \"Issued_Books\" WHERE actual_return_date IS NULL",
           "overdue_books": """
               SELECT COUNT(*) FROM \"Issued_Books\"
               WHERE actual_return_date IS NULL AND expected_return_date < CURRENT_DATE
           """
       }

       stats = {}
       for key, query in queries.items():
           result = db.execute_query(query, fetch="one")
           if result:
               # Результат может быть кортежем или словарем в зависимости от драйвера
               stats[key] = list(result.values())[0] if isinstance(result, dict) else result[0]

       return stats

   # Использование:
   db = DB()
   db.connect()
   statistics = get_library_statistics(db)
   print(f"Статистика библиотеки:")
   for key, value in statistics.items():
       print(f"  {key}: {value}")