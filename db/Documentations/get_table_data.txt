Метод get_table_data() класса DB

Назначение:
Возвращает все данные из указанной таблицы в виде списка словарей. Каждый словарь представляет одну строку таблицы с ключами-названиями колонок и значениями данных.

Параметры:
- table_name (str): название таблицы, из которой нужно получить данные
  Примеры: "Books", "Readers", "Issued_Books"

Возвращаемое значение:
- List[Dict[str, Any]]: список словарей, где каждый словарь представляет строку таблицы
- Пустой список если таблица не существует, нет подключения или произошла ошибка
- Пример:
  [
    {'id_book': 1, 'title': 'Война и мир', 'authors': ['Л.Н. Толстой'], 'genre': 'Роман', ...},
    {'id_book': 2, 'title': 'Преступление и наказание', 'authors': ['Ф.М. Достоевский'], 'genre': 'Роман', ...}
  ]

Выполняемые действия:

1. Проверка подключения:
   - Вызывает is_connected() для проверки наличия активного соединения
   - Если нет подключения, возвращает пустой список

2. Проверка существования таблицы в метаданных:
   - Проверяет наличие table_name в self.tables
   - Если таблица не определена в метаданных, возвращает пустой список

3. Выполнение SELECT-запроса:
   - Создает SELECT * запрос для указанной таблицы
   - Выполняет запрос через engine.connect()
   - Преобразует результаты в список словарей

4. Логирование:
   - INFO: "Выполнение DML: SELECT * FROM \"{table_name}\"" (перед выполнением)
   - INFO: "Получено {count} строк из таблицы '{table_name}'" (при успехе)
   - ERROR: "Нет подключения к БД" (если нет соединения)
   - ERROR: "Таблица '{table_name}' не определена в метаданных приложения" (если таблица не найдена)
   - ERROR: "Ошибка получения данных из таблицы '{table_name}': {сообщение ошибки}" (при исключениях)

Примеры вызова:

1. Базовое использование:
   db = DB()
   if db.connect() and db.create_schema():
       # Добавим тестовые данные
       db.insert_data("Books", {
           "title": "Война и мир",
           "authors": ["Л.Н. Толстой"],
           "genre": "Роман",
           "deposit_amount": 500.00,
           "daily_rental_rate": 10.00
       })

       # Получаем все данные
       books_data = db.get_table_data("Books")
       for book in books_data:
           print(f"Книга: {book['title']} - {book['authors']}")

2. Обработка пустой таблицы:
   db = DB()
   db.connect()
   db.create_schema()
   empty_books = db.get_table_data("Books")
   print(f"Книг в таблице: {len(empty_books)}")  # Вывод: 0

3. С обработкой ошибок:
   db = DB()
   try:
       if db.connect():
           data = db.get_table_data("NonExistentTable")
           if not data:
               print("Таблица не существует или пуста")
   except Exception as e:
       print(f"Ошибка при получении данных: {e}")

4. Для отображения данных:
   def display_table_contents(db, table_name):
       if not db.is_connected():
           print("Нет подключения к БД")
           return

       data = db.get_table_data(table_name)
       if not data:
           print(f"Таблица {table_name} пуста или не существует")
           return

       print(f"\nСодержимое таблицы {table_name}:")
       print("-" * 50)
       for i, row in enumerate(data, 1):
           print(f"Запись {i}:")
           for key, value in row.items():
               print(f"  {key}: {value}")
           print()

5. Экспорт данных:
   import json

   db = DB()
   db.connect()
   books_data = db.get_table_data("Books")

   # Сохраняем в JSON
   with open('books_export.json', 'w', encoding='utf-8') as f:
       json.dump(books_data, f, ensure_ascii=False, indent=2, default=str)

Побочные эффекты:
- Выполняет SELECT-запрос к БД (операция чтения)
- Запись DML-операций в лог-файл
- Может создать нагрузку на БД при больших объемах данных
- Использование памяти пропорционально объему данных
- Не модифицирует данные в БД

Особенности:
- Только чтение - безопасная операция
- Возвращает все данные таблицы (может быть ресурсоемко)
- Преобразует данные в удобный формат словарей
- Учитывает типы данных SQLAlchemy
- Потокобезопасный метод

Логирование операций:
- INFO: "Выполнение DML: SELECT * FROM \"{table_name}\""
- INFO: "Получено {count} строк из таблицы '{table_name}'"
- ERROR: "Нет подключения к БД"
- ERROR: "Таблица '{table_name}' не определена в метаданных приложения"
- ERROR: "Ошибка получения данных из таблицы '{table_name}': {сообщение ошибки}"

Ограничения:
- Требует прав на чтение из таблицы
- Может быть медленным для больших таблиц
- Использует память для хранения всех данных
- Не подходит для таблиц с миллионами записей

Рекомендации по использованию:
- Используйте для получения небольших объемов данных
- Применяйте при тестировании и отладке
- Полезен для экспорта данных
- Можно использовать для кэширования небольших справочников
- Для больших таблиц используйте пагинацию или фильтрацию

Примеры возвращаемых значений:
- Для таблицы Books с данными:
  [
    {
      'id_book': 1,
      'title': 'Война и мир',
      'authors': ['Л.Н. Толстой'],
      'genre': 'Роман',
      'deposit_amount': 500.00,
      'daily_rental_rate': 10.00
    }
  ]

- Для пустой таблицы: []
- Для несуществующей таблицы: []
- При ошибках: []

Пример комплексного использования:
   def backup_table_data(db, table_name):
       data = db.get_table_data(table_name)
       if data is not None:
           timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
           filename = f"{table_name}_backup_{timestamp}.json"

           import json
           with open(filename, 'w', encoding='utf-8') as f:
               json.dump(data, f, ensure_ascii=False, indent=2, default=str)

           print(f"Резервная копия {table_name} сохранена в {filename}")
           return True
       else:
           print(f"Ошибка создания резервной копии {table_name}")
           return False